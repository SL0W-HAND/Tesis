\appendix
\chapter{Programa para el calculo de símbolos de  Christoffel}
\label{chap:programa_christoffel}

Este es el programa utilizado para calcular los símbolos de Christoffel de la métrica \ref{eq:genericmetric2} usados en la derivación de la métrica  de Schwarzschild.
%%\lstinputlisting[language=Python]{christofel.py}
\begin{lstlisting}[language=Python, caption=Programa para el calculo de símbolos de  Christoffel]
from sympy import symbols,trigsimp,factor,cancel, Function, Matrix, Rational, diff, simplify, latex, init_printing, sin, cos

# Definición de Símbolos
t, r, theta, phi, Gamma_sym = symbols('t r theta phi Gamma') 

indices = [t, r, theta, phi] 


# Parámetros y expresiones para la métrica de Kerr
a, m, c, delta_s, sigma_s, rho_s = symbols('a m c Delta Sigma rho', real=True) # Delta y Sigma (mayúsculas) son símbolos, delta y sigma (minúsculas) se definen abajo

# Expresiones para la métrica (usando _expr para distinguirlas de los símbolos si fuera necesario)
delta = r**2 - 2*m*r + a**2
sigma = (r**2 + a**2)**2 - a**2*sin(theta)**2*delta 
rho = r**2 + a**2*cos(theta)**2


# Función para convertir índices a su forma de LaTeX
def latex_index(index_symbol): 
    index_dict = {'t': 't', 'r': 'r', 'theta': '\\theta', 'phi': '\\phi'}
    return index_dict.get(str(index_symbol), str(index_symbol))


init_printing(use_unicode=True)

A = Function('A', real=True)(r)
B = Function('B', real=True)(r)


# Métrica genérica para la derivación de la métrica de Schwarzschild
g_ij = [
    [-A, 0, 0, 0],
    [0, B, 0, 0],
    [0, 0, r**2, 0],
    [0, 0, 0, r**2*sin(theta)**2]
]



# Métrica inversa g^ij (tu variable 'gij')
gij = [[Matrix(g_ij).inv()[i, j] for j in range(0, len(g_ij))] for i in range(0, len(g_ij))]

# Función para calcular Símbolos de Christoffel
# upperIndex, lowerIndex1, lowerIndex2 son enteros 1-basados (1, 2, 3, 4)
def Christoffel(upperIndex, lowerIndex1, lowerIndex2, latex_output=True):
    
    # Obtener los símbolos de coordenadas correspondientes a los índices
    # Ahora 'indices' es la lista [t, r, theta, phi]
    upperIndexSymbol = indices[upperIndex ]
    lowerIndexSymbol1 = indices[lowerIndex1 ]
    lowerIndexSymbol2 = indices[lowerIndex2 ]

    Christoffel_sum = 0 # Usé Christoffel_sum para la variable de suma, pero tu 'Christoffel = 0' original también funciona debido al alcance.
    
    # La suma ahora itera correctamente de 0 a 3 (len(indices) es 4)
    for i in range(0, len(indices), 1): # 'i' es el índice de suma (0-basado)
        
       
        term_inv_metric = gij[upperIndex][i]
        
        diff1 = diff(g_ij[i][lowerIndex2], lowerIndexSymbol1)
        diff2 = diff(g_ij[i][lowerIndex1], lowerIndexSymbol2)
        diff3 = diff(g_ij[lowerIndex1][lowerIndex2], indices[i])
        
        Christoffel_sum += Rational(1,2) * term_inv_metric * (diff1 + diff2 - diff3)


    Christoffel_simplified = simplify(Christoffel_sum)  # Simplificación general
    Christoffel_simplified = trigsimp(Christoffel_simplified)  # Simplifica funciones trigonométricas
    Christoffel_simplified = cancel(Christoffel_simplified)  #

    # Imprimir en pantalla los coeficientes no cero
    if (Christoffel_simplified != 0):
        if (latex_output == True):
            latex_str = f"\\Gamma^{{{latex_index(upperIndexSymbol)}}}{{ }}_{{{latex_index(lowerIndexSymbol1)} {latex_index(lowerIndexSymbol2)}}} &= {latex(Christoffel_simplified)} \\\\"
            print(latex_str)
        else:
            latex_str = f"\\Gamma^{{{upperIndex}}}{{ }}_{{{lowerIndex1} {lowerIndex2}}} &= {latex(Christoffel_simplified)} \\\\"
            print(latex_str)
    
    return Christoffel_simplified


def Christoffel_all(latex_output=False):
    """
    Crea un objeto con indices tipo tensor (que no es un tensor) que contiene todos los Christoffel

    """
    Christoffel_list = []
    for i in range(0, 4, 1):      # Índice superior k
        i_list = []
        for j in range(0, 4, 1):  # Primer índice inferior m
            j_list = []
            for k_loop in range(0, 4, 1): # Segundo índice inferior n 
                Christoffel_sym = Christoffel(i, j, k_loop, latex_output=latex_output)
                j_list.append(Christoffel_sym)
            i_list.append(j_list)
        Christoffel_list.append(i_list)

    return Christoffel_list

Christoffel_all()
\end{lstlisting}

\chapter{Programa para el calculo del tensor de Ricci}
\label{chap:programa_ricci}
Este programa calcula la los componentes del tensor de Ricci por la definición de \ref{eq:ricci_tensor}

\begin{lstlisting}[language=Python, caption=Programa para el calculo del tensor de Ricci]
from christoffel import Christoffel_all # importar el programa anterior
from sympy import *

t, r, theta, phi, = symbols('t r theta phi') 

indices = [t, r, theta, phi]

# Lista con los símbolos de Christoffel
Christoffel_symbols = Christoffel_all()


# Por definición el tensor de Ricci es la contracción de 2 indices del tensor de Riemann

# mu , nu siendo los indices del Ricci
for mu in range(0,4,1):
    for nu in range(0,4,1):
        ricci_mu_nu = 0
        ##sobre el indice mudo alpha
        for alpha in range(0,4,1):
            ricci_mu_nu += diff(Christoffel_symbols[alpha][mu][nu],indices[alpha]) -diff(Christoffel_symbols[alpha][mu][alpha],indices[nu]) 
            # indice mudo lambda
            for lam in range(0,4,1):
                ricci_mu_nu +=  Christoffel_symbols[alpha][alpha][lam]*Christoffel_symbols[lam][mu][nu] - Christoffel_symbols[alpha][nu][lam]*Christoffel_symbols[lam][mu][alpha]
        ricci_mu_nu = cancel(ricci_mu_nu)
        ricci_mu_nu = simplify(ricci_mu_nu)
 
        # imprimir en pantalla los componentes no cero
        if ricci_mu_nu != 0:
            print(f"R_{{{mu}{nu}}} &= {latex(ricci_mu_nu)} \\\\")
\end{lstlisting}

\input{Anexos/Hamilton.tex}


\section{Codigo para metrica inversa}
\label{sec:codigo_metrica_inversa}
El siguiente código calcula la métrica inversa de Kerr a partir de la métrica covariante.
\begin{lstlisting}[language=Python, caption=Programa para el calculo de la métrica inversa de Kerr]
    from sympy import symbols, Matrix, sin, cos, simplify, pretty_print, factor, cancel, together, trigsimp, latex

# ------------------------------
# Definición de símbolos
# ------------------------------
t, r, theta, phi = symbols('t r theta phi', real=True)
a, m = symbols('a m', real=True)
# Estas son las variables objetivo para el resultado final
delta_s, rho_s, sigma_s = symbols('delta rho sigma', real=True)

def smart_subs(expr, old, new):
    """Sustituye en expr todas las ocurrencias algebraicamente equivalentes a old por new."""
    return expr.replace(
        lambda subexpr: simplify(subexpr - old) == 0,
        lambda subexpr: new
    )

# ------------------------------
# Definición de las expresiones completas
# ------------------------------
delta_expr = r**2 - 2*m*r + a**2
rho_expr   = r**2 + a**2*cos(theta)**2
sigma_expr = (r**2 + a**2)**2 - a**2*sin(theta)**2*(r**2 - 2*m*r + a**2)

# ------------------------------
# Métrica de Kerr (g_ij)
# ------------------------------
g_ij = Matrix([
    [-(1 - 2*m*r/rho_expr),          0, 0, -2*m*a*r*sin(theta)**2/rho_expr],
    [0,                             rho_expr/delta_expr, 0, 0],
    [0,                             0, rho_expr, 0],
    [-2*m*a*r*sin(theta)**2/rho_expr, 0, 0, sigma_expr*sin(theta)**2/rho_expr]
])

# ------------------------------
# Métrica inversa de Kerr (g^ij)
# ------------------------------
gij_inv = g_ij.inv()

# Sustituciones para variables cortas
subs_dict = {
    sigma_expr: sigma_s,
    delta_expr: delta_s,
    rho_expr: rho_s
}

# Simplificación robusta: varias rutinas en cascada
def full_simplify(expr):
    expr = expr.subs(subs_dict)
    expr = together(expr)
    expr = cancel(expr)
    expr = simplify(expr)
    expr = factor(expr)
    expr = trigsimp(expr)
    return expr

gij_inv = gij_inv.applyfunc(full_simplify)
gij_inv = gij_inv.subs(subs_dict)
gij_inv = gij_inv.applyfunc(lambda e: smart_subs(e, sigma_expr, sigma_s))
gij_inv = gij_inv.applyfunc(lambda e: smart_subs(e, delta_expr, delta_s))
gij_inv = gij_inv.applyfunc(lambda e: smart_subs(e, rho_expr, rho_s))


# ------------------------------
# Resultados
# ------------------------------
pretty_print(gij_inv)
print("\n")
print(latex(gij_inv))
\end{lstlisting}



\section{Codigo para la determinacioon de las constantes de movimiento en Kerr}
\label{chap:programa_constantes_kerr}
\begin{lstlisting}[language=Python, caption={Programa para el calculo de las constantes de movimiento en Kerr}]
import numpy as np
from sympy import symbols, Matrix, sin, cos, solveset

# ------------------------------
# 1. Definición de Símbolos
# ------------------------------
r, theta = symbols('r, theta', real=True)
a, M = symbols('a, M', real=True, positive=True)

# ------------------------------
# 2. Definición de Expresiones Auxiliares
# ------------------------------
delta = r**2 - 2 * M * r + a**2
rho2 = r**2 + a**2 * cos(theta)**2
sigma = (r**2 + a**2)**2 - a**2 * sin(theta)**2 * delta

# ------------------------------
# 3. Métrica de Kerr (Covariante g_uv)
# ------------------------------
g_uv = Matrix([
    [-(1 - 2 * M * r / rho2), 0, 0, -2 * M * a * r * sin(theta)**2 / rho2],
    [0, rho2 / delta, 0, 0],
    [0, 0, rho2, 0],
    [-2 * M * a * r * sin(theta)**2 / rho2, 0, 0, sigma * sin(theta)**2 / rho2]
])

# ------------------------------
# 4. Función para Calcular las Constantes de Movimiento Totales
# ------------------------------

def get_total_constants_of_motion(r_0: float, theta_0: float, 
                                  u_r0: float, u_theta0: float, u_phi0: float, 
                                  a_val: float = 0.9, M_val: float = 1.0,
                                  mu: float = 1.0, c: float = 1.0):
    """
    Calcula las constantes de movimiento TOTALES.
    Versión robusta que maneja correctamente el caso ecuatorial (theta = pi/2).
    """
    g_uv_val = g_uv.subs([(r, r_0), (theta, theta_0), (a, a_val), (M, M_val)])

    u_t0_sym = symbols('u_t', real=True, positive=True)
    u_vector = [u_t0_sym, u_r0, u_theta0, u_phi0]
    
    # Ecuación de normalización: g_uv * U^u * U^v = -c^2
    norm_eq = sum(g_uv_val[i, j] * u_vector[i] * u_vector[j] for i in range(4) for j in range(4)) + c**2
    
    solutions = solveset(norm_eq, u_t0_sym)
    u_t0_val = None
    for sol in solutions:
        if sol.is_real and sol > 0:
            u_t0_val = float(sol)
            break
            
    if u_t0_val is None:
        raise ValueError("No se encontró una solución real y positiva. Revisa las condiciones iniciales.")

    # Calcular E y Lz (escalados por la masa mu)
    E = mu * -(g_uv_val[0, 0] * u_t0_val + g_uv_val[0, 3] * u_phi0)
    Lz = mu * (g_uv_val[3, 0] * u_t0_val + g_uv_val[3, 3] * u_phi0)

    # --- Calcular la Constante de Carter Total (Q) - FORMA ROBUSTA ---
    rho2_val = float(rho2.subs([(r, r_0), (theta, theta_0), (a, a_val)]))
    
    # Comprobar si estamos en el ecuador para usar la fórmula simplificada
    # Se usa una pequeña tolerancia para evitar errores de punto flotante
    if abs(theta_0 - np.pi/2) < 1e-9:
        # En el ecuador, cos(theta) es 0, por lo que Q se simplifica drásticamente
        Q = (mu * r_0**2 * u_theta0)**2 #  rho2 en el ecuador es r^2
    else:
        # Si no estamos en el ecuador, usamos la fórmula completa
        cos_theta0_val = cos(theta_0)
        sin_theta0_val = sin(theta_0)

        p_theta_sq = (mu * rho2_val * u_theta0)**2

        if abs(sin_theta0_val) < 1e-9:
            term_Lz = 0 if abs(Lz) < 1e-9 else float('inf')
        else:
            term_Lz = Lz**2 / sin_theta0_val**2

        term_E = a_val**2 * (mu**2 * c**2 - E**2 / c**2)
        Q = p_theta_sq + cos_theta0_val**2 * (term_Lz + term_E)

    return E, Lz, Q

# ------------------------------
# 5. Ejemplo de Uso 
# ------------------------------
print("--- Test partícula en caída ---")
try:
    E_fall, Lz_fall, Q_fall = get_total_constants_of_motion(
        r_0=6.0, theta_0=np.pi/2, 
        u_r0=0.0, u_theta0=0.0, u_phi0=0.0,
        a_val=0.9, M_val=1.0, mu=1.0, c=1.0
    )
    print(f"  - Energía Total: {E_fall:.6f}")
    print(f"  - Momento Angular Total: {Lz_fall:.6f}")
    print(f"  - Constante de Carter Total: {Q_fall:.6f}")

except ValueError as e:
    print(f"Error: {e}")

\end{lstlisting}

\section{Programa geodesicas}
\label{chap:programa_geodesicas}
Este programa calcula las geodésicas en la métrica de Kerr usando las constantes de movimiento 

\begin{lstlisting}[language=Python, caption=Programa para el calculo de las geodesicas en Kerr]
    import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.patches import Circle


# --- Variables Globales para el Manejo de Puntos de Inflexión ---
# Guardan el signo de la velocidad para saber si la partícula va hacia adentro/afuera
# o hacia arriba/abajo.
sign_r = 1.0  # Empezamos moviéndonos hacia afuera
sign_theta = 1.0 # Empezamos moviéndonos hacia el polo norte

# Guardan el valor de la derivada anterior para ayudar a detectar el cambio de signo.
dr_dtau_prev = 0.0
dtheta_dtau_prev = 0.0


# Constantes del agujero negro
a = 0.9
m = 1.0
c = 1.0

# Constantes de la geodésica
# Estas se calclulan por separado
# Constantes de movimiento para una órbita inclinada y en precesión
E = 0.95     # Energía 
Lz = 3.0     # Momento angular axial
Q = 15.0     # Constante de Carter (alta para una gran inclinación)
mu = 1.0     # Masa de la partícula (1 para masiva, 0 para fotón)

# Condiciones iniciales [r0, theta0, phi0, t0]
r0 = 6.0*m
theta0 = np.pi / 3  # Inclinación inicial de 60 grados respecto al ecuador
phi0 = 0.0
t0 = 0.0
y0 = [r0, theta0, phi0, t0]


tau_max = 30
tau_span = [0, tau_max]

def kerr_geodesics(tau, y, m, a, E, Lz, Q):
    """
    Define el sistema de EDOs para las geodésicas de Kerr en tiempo Mino (tau).
    El vector de estado es y = [r, theta, phi, t].
    """
    global sign_r, sign_theta, dr_dtau_prev, dtheta_dtau_prev
    r, theta, phi, t = y

    # Términos auxiliares de la métrica
    Delta = r**2 - 2 * m * r + a**2


    Rr = ((r**2 + a**2) * (E/c) - a * Lz)**2 - Delta * ((mu * c * r)**2 + (Lz - a * (E/c))**2 + Q)

    # El término np.sin(theta)**2 + 1e-9 evita la división por cero en los polos.
    Th = Q - np.cos(theta)**2 * (Lz**2 / (np.sin(theta)**2 + 1e-9)+a**2 * ((mu* c)**2 - (E/c)**2))

    # Se truncan a cero valores negativos pequeños que puedan surgir de errores de precisión.
    Rr = max(Rr, 0.0)
    Th = max(Th, 0.0)

    # Detección y manejo simple de puntos de inflexión (turning points)
    # Si el potencial es casi cero y la velocidad anterior era mayor, invertimos la dirección.
    if Rr < 1e-7 and dr_dtau_prev**2 > Rr:
        sign_r *= -1
    if Th < 1e-7 and dtheta_dtau_prev**2 > Th:
        sign_theta *= -1

    # Derivadas con respecto al tiempo Mino (tau)
    dr_dtau = sign_r * np.sqrt(Rr)
    dtheta_dtau = sign_theta * np.sqrt(Th)

    # Actualizamos los valores de las derivadas para la siguiente iteración
    dr_dtau_prev = dr_dtau
    dtheta_dtau_prev = dtheta_dtau

    dphi_dtau = (Lz / (np.sin(theta)**2 + 1e-9) - a * (E/c)) + (a *((r**2 + a**2) * (E/c) - a * Lz) / Delta)

    dt_dtau = - a * (a * (E/c) * np.sin(theta)**2 - Lz) + ((r**2 + a**2) * ((r**2 + a**2) * (E/c) - a * Lz) / Delta)

    return [dr_dtau, dtheta_dtau, dphi_dtau, dt_dtau]

print("Iniciando la integración numérica...")

# Genera 2000 puntos espaciados uniformemente para una curva suave.
t_eval_points = np.linspace(tau_span[0], tau_span[1], 2000) 

# Llamada al solver de EDOs de SciPy
sol = solve_ivp(
    fun=kerr_geodesics,
    t_span=tau_span,
    y0=y0,
    args=(m, a, E, Lz, Q),
    method='Radau',      # Un método robusto para este tipo de problemas
    dense_output=True,   # Permite obtener una solución continua y suave
    rtol=1e-8,           # Tolerancia relativa para alta precisión
    atol=1e-8,           # Tolerancia absoluta
    t_eval=t_eval_points # Puntos donde se evalúa la solución
)


print("Integración completada con éxito.")


# Extraer los resultados de la solución
r, theta, phi, t = sol.y

# --- 3. Visualización de la Órbita ---

print("Generando la visualización 3D...")

# Convertir de coordenadas de Boyer-Lindquist a cartesianas para la gráfica
x = r * np.sin(theta) * np.cos(phi)
y = r * np.sin(theta) * np.sin(phi)
z = r * np.cos(theta)

# Crear la figura y el eje 3D
fig = plt.figure(figsize=(12, 10))
ax = fig.add_subplot(111, projection='3d')

# Malla de parámetros
u = np.linspace(0, 2 * np.pi, 200)
v = np.linspace(0, np.pi, 200)

# Ergoesfera
r_e = m + np.sqrt(m**2 - (a*np.cos(v))**2)
x_e = r_e * np.outer(np.cos(u), np.sin(v))
y_e = r_e * np.outer(np.sin(u), np.sin(v))
z_e = r_e * np.outer(np.ones(np.size(u)), np.cos(v))
ax.plot_surface(x_e, y_e, z_e, color='purple', alpha=0.25, rstride=5, cstride=5)

# Horizonte de sucesos
r_h = m + np.sqrt(m**2 - a**2)
x_bh = r_h * np.outer(np.cos(u), np.sin(v))
y_bh = r_h * np.outer(np.sin(u), np.sin(v))
z_bh = r_h * np.outer(np.ones(np.size(u)), np.cos(v))
ax.plot_surface(x_bh, y_bh, z_bh, color='black', alpha=0.6, rstride=5, cstride=5)

# Círculo del horizonte en el plano ecuatorial
theta = np.linspace(0, 2*np.pi, 400)
x_circ = a * np.cos(theta)
y_circ = a * np.sin(theta)
z_circ = np.zeros_like(theta)
ax.plot(x_circ, y_circ, z_circ, color="red", lw=2, label="Singularidad r=a")

# --- Trayectoria (se dibuja al final, queda arriba de todo) ---
ax.plot(x, y, z, label='Órbita Precesante', lw=1, color='cyan')

# Configuración de la gráfica
ax.set_title("Orbita en el espacio-tiempo de Kerr", fontsize=16)
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.legend()

legend_elements = [
    Patch(facecolor='purple', edgecolor='k', alpha=0.25, label='Ergoesfera'),
    Patch(facecolor='black', edgecolor='k', alpha=0.6, label='Horizonte de sucesos'),
]

ax.legend(handles=legend_elements + ax.get_legend_handles_labels()[0], loc="upper right")

# Ajustar límites
max_range = np.max(np.abs([x, y, z])) * 1.2
ax.set_xlim([-max_range, max_range])
ax.set_ylim([-max_range, max_range])
ax.set_zlim([-max_range, max_range])

# Ángulo de vista
ax.view_init(elev=30, azim=45)

# Fondo blanco
ax.set_facecolor("white")

plt.tight_layout()

plt.show()
# --- 4. Visualización 2D en el plano XY ---

fig, ax = plt.subplots(figsize=(8, 8))

# Trayectoria proyectada en XY
ax.plot(x, y, color="cyan", lw=1, label="Órbita Precesante")

# Horizonte de sucesos (círculo en XY)
circle_h = Circle((0, 0), r_h, color="black", alpha=0.6, label="Horizonte de sucesos")
ax.add_patch(circle_h)

# Ergoesfera (círculo en XY)
r_e_eq = m + np.sqrt(m**2 - 0)  # ergo radio en el ecuador
circle_e = Circle((0, 0), r_e_eq, color="purple", alpha=0.25, label="Ergoesfera")
ax.add_patch(circle_e)

#Singularidad
circle_s = Circle((0, 0), a, color="red", alpha=0.9, label="Singularidad", fill=False)
ax.add_patch(circle_s)

# Configuración
ax.set_aspect("equal")
ax.set_xlabel("X")
ax.set_ylabel("Y")

ax.legend()


plt.show()
\end{lstlisting}

\section{programa para funciones de r circulares}
\label{chap:programa_orbitas_circulares_kerr}

\begin{lstlisting}[language=Python, caption={Cálculo numérico de las constantes para órbitas circulares en Kerr}, label={lst:kerr_circular_orbits}]
import numpy as np
import matplotlib.pyplot as plt
from sympy import symbols, diff, lambdify
from scipy.optimize import fsolve

# ------------------------------
# 1. PARÁMETROS DE CONFIGURACIÓN
# ------------------------------
# Constantes físicas y del agujero negro
PARAMS = {
    'm': 1.0,      # Masa del agujero negro
    'a': 0.9,      # Parámetro de espín (spin)
    'mu': 1.0,     # Masa de la partícula de prueba
    'c': 1.0       # Velocidad de la luz (unidades geometrizadas)
}

# Parámetros de simulación
R_START = PARAMS['m'] + np.sqrt(PARAMS['m']**2 - PARAMS['a']**2) + 0.1  # Justo fuera del horizonte
R_END = 6.0
N_POINTS = 5000
Q_VALS = [0, 5, 10] # Valores del parámetro de Carter a simular

# ------------------------------
# 2. DEFINICIÓN SIMBÓLICA (con SymPy)
# ------------------------------
r, a, m, E, Lz, Q, mu, c = symbols('r a m E L_z Q mu c', real=True)

# Ecuaciones de la geodésica de Kerr
delta = r**2 - 2*m*r + a**2
P_func = (r**2 + a**2)*E - a*Lz
R_func = P_func**2 - delta*(mu**2*r**2 + (Lz - a*E)**2 + Q)
R_prime = diff(R_func, r)

# ------------------------------
# 3. CONVERSIÓN A FUNCIONES NUMÉRICAS (con Lambdify)
# ------------------------------
# Se convierten las expresiones de SymPy en funciones de NumPy para un cálculo rápido.
VARIABLES = [E, Lz, r, Q, a, m, mu, c]
R_numeric = lambdify(VARIABLES, R_func, 'numpy')
R_prime_numeric = lambdify(VARIABLES, R_prime, 'numpy')

# ------------------------------
# 4. FUNCIÓN SOLUCIONADORA (con SciPy)
# ------------------------------
def solve_equations(initial_guess, r_val, Q_val, params):
    """
    Resuelve el sistema R=0 y R'=0 para E y Lz usando fsolve de SciPy.
    
    Args:
        initial_guess (list): Valores iniciales para [E, Lz].
        r_val (float): Valor del radio.
        Q_val (float): Valor del parámetro de Carter.
        params (dict): Diccionario con los parámetros del agujero negro.
        
    Returns:
        tuple: (E, Lz) o (nan, nan) si la solución no se encuentra.
    """
    # Función objetivo para fsolve. Debe devolver [0, 0] en la solución.
    def objective_func(variables):
        E_sol, Lz_sol = variables
        args = (r_val, Q_val, params['a'], params['m'], params['mu'], params['c'])
        
        eq1 = R_numeric(E_sol, Lz_sol, *args)
        eq2 = R_prime_numeric(E_sol, Lz_sol, *args)
        
        return [eq1, eq2]

    try:
        # fsolve es el equivalente numérico de nsolve
        solution, _, success_flag, _ = fsolve(objective_func, initial_guess, full_output=True)
        if success_flag == 1:
            return float(solution[0]), float(solution[1])
        else:
            return np.nan, np.nan
    except RuntimeError:
        # fsolve puede lanzar un error si no converge
        return np.nan, np.nan


#r_consulta = 3
#q_consulta = 4
#E_consulta, Lz_consulta = solve_equations([0.9, 2.0], r_consulta, q_consulta, PARAMS)
#print(f"Para r={r_consulta} y Q={q_consulta}, se obtiene E={E_consulta:.6f}, Lz={Lz_consulta:.6f}")

# ------------------------------
# 5. BUCLE PRINCIPAL DE CÁLCULO
# ------------------------------
print("Iniciando cálculos...")
r_vals = np.linspace(R_START, R_END, N_POINTS)
results = {}

for q in Q_VALS:
    print(f"Calculando para Q = {q}...")
    E_vals, Lz_vals = [], []
    # Valores iniciales para el primer punto del radio
    current_guess = [0.9, 2.0] 
    
    for rv in r_vals:
        E_sol, Lz_sol = solve_equations(current_guess, rv, q, PARAMS)
        E_vals.append(E_sol)
        Lz_vals.append(Lz_sol)
        
        # Optimización: Usa la solución actual como el valor inicial para el siguiente punto.
        # Esto hace que el solucionador sea mucho más rápido y estable.
        if not np.isnan(E_sol):
            current_guess = [E_sol, Lz_sol]
            
    results[q] = {'E': E_vals, 'Lz': Lz_vals}

print("Cálculo finalizado.")

# ------------------------------
# 6. VISUALIZACIÓN DE RESULTADOS
# ------------------------------
# Usamos el modo orientado a objetos de Matplotlib para mayor control



# Líneas verticales de referencia
r_horizonte = PARAMS['m'] + np.sqrt(PARAMS['m']**2 - PARAMS['a']**2)
r_ergoesfera = 2 * PARAMS['m']

plt.figure()
plt.axvline(x=r_horizonte, color='red', linestyle='--', label='Horizonte de eventos ($r_+$)')
plt.axvline(x=r_ergoesfera, color='black', linestyle=':', label='Ergoesfera estática ($r_E$)')
plt.grid(True, linestyle='--', alpha=0.6)

# Gráfica para E(r)
for q, data in results.items():
    plt.plot(r_vals, data['E'], label=f'Q={q}')
plt.ylabel("E")
plt.xlabel("r")
plt.legend()
plt.ylim(0, 6)

plt.show()


plt.figure()
plt.axvline(x=r_horizonte, color='red', linestyle='--', label='Horizonte de eventos ($r_+$)')
plt.axvline(x=r_ergoesfera, color='black', linestyle=':', label='Ergoesfera estática ($r_E$)')
plt.grid(True, linestyle='--', alpha=0.6)   
# Gráfica para Lz(r)
for q, data in results.items():
    plt.plot(r_vals, data['Lz'], label=f'Q={q}')
plt.ylabel("$L_z$")
plt.xlabel("r")
plt.legend()
plt.ylim(0, 6)

plt.show()
\end{lstlisting}